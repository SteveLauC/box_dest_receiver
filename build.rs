//! This build.rs does 2 things:
//!
//! 1. Compile the static_inline_funcs.c/h, move the .a file to `target/<PROFILE>`
//! 2. Bindgen the Postgres symbols we need.

use std::env;
use std::path::PathBuf;

const NEEDED_PG_HEADERS: &str = "needed_pg_headers.h";
const ENV_PG_INCLUDE_DIR: &str = "PG_INCLUDE_DIR";

fn main() {
    let pg_include_dir = env::var(ENV_PG_INCLUDE_DIR).unwrap_or_else(|_e| {
        panic!(
            "{} not set, could not find the Postgres include directory",
            ENV_PG_INCLUDE_DIR
        );
    });

    cc::Build::new()
        .file("static_inline_c_funcs.c")
        .include(&pg_include_dir)
        .include(format!("{}/server", &pg_include_dir))
        .compile("static_inline_c_funcs");

    // Copy the compiled static_inline_c_funcs.a library to `<PROJECT>/target/<PROFILE>`
    let out_dir_str = env::var("OUT_DIR").unwrap();
    let out_dir = std::path::Path::new(&out_dir_str);
    let profile = env::var("PROFILE").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let lib_name = "libstatic_inline_c_funcs.a";
    let src_path = out_dir.join(lib_name);
    let target_lib_dir = PathBuf::from(manifest_dir).join("target").join(profile);
    let dest_path = target_lib_dir.join(lib_name);
    // Ensure the target directory exists
    std::fs::create_dir_all(&target_lib_dir).unwrap();
    std::fs::copy(&src_path, &dest_path).expect("Failed to copy static_inline_funcs.a library");

    println!("cargo:rerun-if-env-changed={}", ENV_PG_INCLUDE_DIR);

    let needed_pg_headers = r#"
/*-------------------------------------------------------------------------
 *
 * needed_pg_headers.h
 *    Generated by build.rs
 *-------------------------------------------------------------------------
 */

#include "postgres.h"
#include "access/tupdesc.h"
#include "executor/tuptable.h"
#include "tcop/dest.h"
#include "fmgr.h"
#include "utils/syscache.h"
#include "utils/lsyscache.h"

#include "static_inline_c_funcs.h"
"#;

    std::fs::write(NEEDED_PG_HEADERS, needed_pg_headers).unwrap_or_else(|e| {
        panic!(
            "couldn't write {} due to error \"{}\"",
            NEEDED_PG_HEADERS, e
        );
    });

    println!("cargo:rerun-if-changed={}", NEEDED_PG_HEADERS);

    let bindings = bindgen::Builder::default()
        .header(NEEDED_PG_HEADERS)
        // Add the PostgreSQL include directories
        .clang_arg(format!("-I{}/server", pg_include_dir))
        .clang_arg(format!("-I{}", pg_include_dir))
        // Some libs need by Postgres are installed using Homebrew
        .clang_arg("-I/opt/homebrew/include")
        .clang_arg("-I/usr/local/include")
        .clang_arg("-I/usr/include")
        .allowlist_type("DestReceiver")
        .allowlist_type("TupleTableSlot")
        .allowlist_type("TupleDesc")
        .allowlist_type("FormData_pg_attribute")
        .allowlist_type("Form_pg_attribute")
        .allowlist_type("CommandDest")
        .allowlist_type("Datum")
        .allowlist_type("AttrNumber")
        .allowlist_type("Oid")
        .allowlist_type("CompactAttribute")
        .allowlist_type("SysCacheIdentifier")
        .allowlist_function("OidOutputFunctionCall")
        .allowlist_function("SearchSysCache")
        .allowlist_function("ReleaseSysCache")
        .allowlist_function("SysCacheGetAttr")
        .allowlist_function("getTypeOutputInfo")
        // Our wrappers
        .allowlist_function("callable_slot_getattr")
        .allowlist_function("callable_TupleDescAttr")
        .generate()
        .expect("Unable to generate bindings");

    bindings
        .write_to_file(out_dir.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
